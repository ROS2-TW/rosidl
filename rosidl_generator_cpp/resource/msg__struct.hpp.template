// generated from rosidl_generator_cpp/resource/msg__struct.hpp.template

@#######################################################################
@# EmPy template for generating <msg>__struct.hpp files
@#
@# Context:
@#  - spec (rosidl_parser.MessageSpecification)
@#    Parsed specification of the .msg file
@#  - subfolder (string)
@#    The subfolder / subnamespace of the message
@#    Either 'msg' or 'srv'
@#  - get_header_filename_from_msg_name (function)
@#######################################################################
@
@{
from rosidl_generator_cpp import escape_string
from rosidl_generator_cpp import msg_type_to_cpp
from rosidl_generator_cpp import cpp_type_of_array 
from rosidl_generator_cpp import MSG_TYPE_TO_CPP
from rosidl_generator_cpp import value_to_cpp

cpp_namespace = '%s::%s::' % (spec.base_type.pkg_name, subfolder)
cpp_class = '%s_' % spec.base_type.type
cpp_full_name = '%s%s' % (cpp_namespace, cpp_class)
cpp_full_name_with_alloc = '%s<ContainerAllocator>' % (cpp_full_name)

bounded_primitive_types = ['byte', 'int8', 'int16', 'int32', 'int64', 'char', 'uint8', 'uint16', 'uint32', 'uint64']
}@
@
#ifndef __@(spec.base_type.pkg_name)__@(subfolder)__@(get_header_filename_from_msg_name(spec.base_type.type))__struct__hpp__
#define __@(spec.base_type.pkg_name)__@(subfolder)__@(get_header_filename_from_msg_name(spec.base_type.type))__struct__hpp__

#include <array>
#include <memory>
#include <string>
#include <vector>

// include message dependencies
@{
for field in spec.fields:
    if not field.type.is_primitive_type():
        print(
            '#include <%s/msg/%s.hpp>' %
            (field.type.pkg_name, get_header_filename_from_msg_name(field.type.type)))
}@

namespace @(spec.base_type.pkg_name)
{

namespace @(subfolder)
{

// message struct
template<class ContainerAllocator>
struct @(spec.base_type.type)_
{
  typedef @(spec.base_type.type)_<ContainerAllocator> Type;

@# constructors (with and without allocator)
@[for (alloc_type, alloc_name) in [['', ''], ['const ContainerAllocator & ', '_alloc']]]@
  @(spec.base_type.type)_(@(alloc_type + alloc_name))
@# generate initializer lists
@{
op = ':'
for field in spec.fields:
    # dynamic arrays require allocator if available
    if alloc_name and field.type.is_array and \
            (field.type.array_size is None or field.type.is_upper_bound):
        print('  %s %s(%s)' % (op, field.name, alloc_name))
        op = ','

    # if default value is available set it in initializer list
    elif field.type.is_primitive_type() and field.default_value is not None:
        cpp_value = value_to_cpp(field.type, field.default_value)
        print('  %s %s(%s)' % (op, field.name, cpp_value))
        op = ','
}@
  {
@# generate constructor body
@{
for field in spec.fields:
    # default values of dynamic arrays with allocators if available
    if alloc_name and field.type.is_array and \
            (field.type.array_size is None or field.type.is_upper_bound) and \
            field.type.is_primitive_type() and field.default_value is not None:
        cpp_value = value_to_cpp(field.type, field.default_value)
        print('    %s = %s;' % (field.name, cpp_value))
}@
  }
@[end for]@

  // field types and members
@[for field in spec.fields]@
  typedef @(msg_type_to_cpp(field.type))
    _@(field.name)_type;
  _@(field.name)_type @(field.name);
@[end for]@

  // setters for named parameter idiom
@[for field in spec.fields]@
  Type * set__@(field.name)(const @(msg_type_to_cpp(field.type)) & _arg)
  {
    this->@(field.name) = _arg;
    return this;
  }
@[end for]@

  // constants
@[for constant in spec.constants]@
@[if (constant.primitive_type in ['byte', 'int8', 'int16', 'int32', 'int64', 'char'])]@
  enum { @(constant.name) = @(int(constant.value)) };
@[elif (constant.primitive_type in ['uint8', 'uint16', 'uint32', 'uint64'])]@
  enum { @(constant.name) = @(int(constant.value))u };
@[else]@
  static const @(MSG_TYPE_TO_CPP[constant.primitive_type]) @(constant.name);
@[end if]@
@[end for]@

  // pointer types
  typedef @(cpp_full_name)<ContainerAllocator> *
    Ptr;
  typedef const @(cpp_full_name)<ContainerAllocator> *
    ConstPtr;
  typedef std::shared_ptr<@(cpp_full_name)<ContainerAllocator>>
    SharedPtr;
  typedef std::shared_ptr<@(cpp_full_name)<ContainerAllocator> const>
    ConstSharedPtr;

  typedef std::unique_ptr<@(cpp_full_name)<ContainerAllocator>>
    UniquePtr;
  typedef std::unique_ptr<@(cpp_full_name)<ContainerAllocator> const>
    ConstUniquePtr;

  typedef std::weak_ptr<@(cpp_full_name)<ContainerAllocator>>
    WeakPtr;
  typedef std::weak_ptr<@(cpp_full_name)<ContainerAllocator> const>
    ConstWeakPtr;

  //comparison operators
  bool operator==(const @(spec.base_type.type)_ & other) const
  {
@[for field in spec.fields]@
    if (this->@(field.name) != other.@(field.name)) {
      return false;
    }
@[end for]@
    return true;
  }
  bool operator!=(const @(spec.base_type.type)_ & other) const
  {
    return !this->operator==(other);
  }

  // Message type introspection
  /*
  static bool has_bounded_size()
  {
@[if not spec.has_bounded_size()]@
    return false;
@[elif spec.base_type.is_primitive_type() or all([field.type.is_primitive_type() for field in spec.fields])]@
    return true;
@[else]@
    bool has_bounded_size = true;
@[for msg_field in [field for field in spec.fields if not field.type.is_primitive_type()]]@
@[if msg_field.type.is_array]@
    has_bounded_size &= @(cpp_type_of_array(msg_field.type))::has_bounded_size();
@[else]@
    has_bounded_size &= @(msg_type_to_cpp(msg_field.type))::has_bounded_size();
@[end if]@
@[end for]@
    return has_bounded_size;
@[end if]@
  }
  */


}; // struct @(cpp_class)

// typedef to use template instance with default allocator
typedef @(cpp_full_name)<std::allocator<void>>
  @(spec.base_type.type);

// constants requiring out of line definition
@[for c in spec.constants]@
@[if c.primitive_type not in bounded_primitive_types]@
template<typename ContainerAllocator>
const @(MSG_TYPE_TO_CPP[c.primitive_type])
@(spec.base_type.type)_<ContainerAllocator>::@(c.name) =
@[if c.primitive_type == 'string']@
  "@(escape_string(c.value))";
@[elif c.primitive_type == 'bool']@
  @(int(c.value));
@[else]@
  @(c.value);
@[end if]@
@[end if]@
@[end for]@

}  // namespace @(subfolder)

}  // namespace @(spec.base_type.pkg_name)

#ifndef __ALL_MSG__BASIC_TEMPLATES
#define __ALL_MSG__BASIC_TEMPLATES

  template<typename T>
  struct has_bounded_size { };

@#@[for bounded_type in ['int8', 'int16', 'int32', 'int64', 'char', 'uint8', 'uint16', 'uint32', 'uint64']]@
@[for bounded_type in ['bool', 'char', 'uint8_t', 'int8_t', 'uint16_t', 'int16_t', 'uint32_t', 'int32_t', 'uint64_t', 'int64_t', 'float', 'double']]@
  template<>
  struct has_bounded_size<@(bounded_type)> { static const bool value = true; };
@[end for]@

  // TODO(jacquelinekay): for now, all vectors and strings are considered unbounded
  template<>
  struct has_bounded_size<std::string> { static const bool value = false; };

  template<typename T>
  struct has_bounded_size<std::vector<T>> { static const bool value = false; };

#endif  /* __ALL_MSG__BASIC_TEMPLATES */

#ifndef __@(spec.base_type.pkg_name)__@(subfolder)__@(get_header_filename_from_msg_name(spec.base_type.type))__TEMPLATES
#define __@(spec.base_type.pkg_name)__@(subfolder)__@(get_header_filename_from_msg_name(spec.base_type.type))__TEMPLATES

@{
template_string=""
if len(spec.fields) == 0:
  template_string = "true"
else:
    for field in spec.fields:
        if field.type.type == 'string':
            template_string += " has_bounded_size<std::string>::value &&"
        elif field.type.is_primitive_type():
            template_string += " has_bounded_size<{}>::value &&".format(MSG_TYPE_TO_CPP[field.type.type])
        else:
            template_string += " has_bounded_size<{}::msg::{}>::value &&".format(field.type.pkg_name, field.type.type)

    template_string = template_string[:len(template_string)-3]
}@

  template<>
  struct has_bounded_size<@(spec.base_type.pkg_name)::@(subfolder)::@(spec.base_type.type)> { static const bool value =@(template_string); };

#endif  /* __@(spec.base_type.pkg_name)__@(subfolder)__@(get_header_filename_from_msg_name(spec.base_type.type))__TEMPLATES */

#endif  // __@(spec.base_type.pkg_name)__@(subfolder)__@(get_header_filename_from_msg_name(spec.base_type.type))__struct__hpp__
