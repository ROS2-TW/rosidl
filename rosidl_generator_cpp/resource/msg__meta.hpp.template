// generated from rosidl_generator_cpp/resource/msg__meta.hpp.template

@#######################################################################
@# EmPy template for generating <msg>__meta.hpp files
@#
@# Context:
@#  - spec (rosidl_parser.MessageSpecification)
@#    Parsed specification of the .msg file
@#  - subfolder (string)
@#    The subfolder / subnamespace of the message
@#    Either 'msg' or 'srv'
@#  - get_header_filename_from_msg_name (function)
@#######################################################################
@
@{
from rosidl_generator_cpp import MSG_TYPE_TO_CPP

cpp_namespace = '%s::%s::' % (spec.base_type.pkg_name, subfolder)
}@
#include <stdint.h>
#include <string>
#include <vector>

#ifndef __ALL_MSG__BASIC_TEMPLATES
#define __ALL_MSG__BASIC_TEMPLATES

  template<typename T>
  struct has_bounded_size { };

@#@[for bounded_type in ['int8', 'int16', 'int32', 'int64', 'char', 'uint8', 'uint16', 'uint32', 'uint64']]@
@[for bounded_type in ['bool', 'char', 'uint8_t', 'int8_t', 'uint16_t', 'int16_t', 'uint32_t', 'int32_t', 'uint64_t', 'int64_t', 'float', 'double']]@
  template<>
  struct has_bounded_size<@(bounded_type)> { static const bool value = true; };
@[end for]@

  // TODO(jacquelinekay): for now, all dynamically sized arrays and strings are considered unbounded
  template<>
  struct has_bounded_size<std::string> { static const bool value = false; };

  template<typename T>
  struct has_bounded_size<std::vector<T>> { static const bool value = false; };

#endif  /* __ALL_MSG__BASIC_TEMPLATES */

#ifndef __@(spec.base_type.pkg_name)__@(subfolder)__@(get_header_filename_from_msg_name(spec.base_type.type))__TEMPLATES
#define __@(spec.base_type.pkg_name)__@(subfolder)__@(get_header_filename_from_msg_name(spec.base_type.type))__TEMPLATES

#include "@(spec.base_type.pkg_name)/@(subfolder)/@(get_header_filename_from_msg_name(spec.base_type.type))__struct.hpp"

@{
template_string=""
if len(spec.fields) == 0:
  template_string = " true"
else:
    for field in spec.fields:
        if field.type.type == 'string':
            template_string += " has_bounded_size<std::string>::value &&"
        elif field.type.is_primitive_type():
            template_string += " has_bounded_size<{}>::value &&".format(MSG_TYPE_TO_CPP[field.type.type])
        else:
            template_string += " has_bounded_size<{}::msg::{}>::value &&".format(field.type.pkg_name, field.type.type)

    template_string = template_string[:len(template_string)-3]
}@

  template<>
  struct has_bounded_size<@(cpp_namespace)@(spec.base_type.type)> {
    static const bool value =@(template_string);
  };

#endif  /* __@(spec.base_type.pkg_name)__@(subfolder)__@(get_header_filename_from_msg_name(spec.base_type.type))__TEMPLATES */
